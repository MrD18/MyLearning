说明:
关于Spring AOP，底层是基于动态代理实现的，下面简单的学习下为什么选择动态代理，而不选择继承实现，装饰者模式实现，下面参考如下业务场景下理解

业务场景:
     业务层如果有业务需求，需要在注册用户，升级用户，和删除用户方法前都进行一次权限验证，
     最原始的方法就是在业务层每个方法前都添加代码验证。这是最原始的方式，在实际业务中有很多的方法，那都需要重写修改，很显然这是不合理的，
     因此衍生如下几个解决方案:

解决方案:
(1)使用继承类，在继承类中对继承的方法进行修改，参考DogDemo01
(2)使用装饰者模式，在装饰类中对原有方法进行装饰修改，参考DogDemo02
(3)使用代理模式，创建出一个代理类，在代理类中修改方法，添加权限，代理模式分为以下两种：
        a 使用静态代理，参考DogDemo03
        b 使用动态代理，动态代理又分为两种，有默认Java JDK动态代理，参考DogDemo04，又有CGlib动态代理，参考DogDemo05
下面使用狗的案例来简单体验一下几个选择的是否可行。


总结:
（1）继承类和装饰者模式均可以实现方法的重写，但存在重写大量方法的可能，不可取。

（2）JDK动态代理也可以解决业务问题，并可以解决书写大量方法代码的问题，但是只能调用被代理对象中接口方法。

（3）Cglib动态代理弥补了JDK动态代理的不足，可以让代理对象调用被代理类中所有的方法（注意final修饰的方法除外）